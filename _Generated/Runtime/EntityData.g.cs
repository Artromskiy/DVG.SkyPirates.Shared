//------------------------------------------------------------------------------
// <auto-generated>
//
// This code was generated by a tool.
// Path: ..\..\..\Generators\EntityDataGenerator.cs
//
// Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated.
// 
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;

using DVG.SkyPirates.Shared.Components.Runtime;
using DVG.SkyPirates.Shared.Components.Config;
using DVG.SkyPirates.Shared.Ids;

namespace DVG.SkyPirates.Shared.Data
{
    [Serializable]
    [DataContract]
    public sealed class EntityData
    {

        [DataMember(Order = 0)]
        public AutoHeal? AutoHeal;
        [DataMember(Order = 1)]
        public BehaviourConfig? BehaviourConfig;
        [DataMember(Order = 2)]
        public BehaviourState? BehaviourState;
        [DataMember(Order = 3)]
        public CactusId? CactusId;
        [DataMember(Order = 4)]
        public Damage? Damage;
        [DataMember(Order = 5)]
        public Direction? Direction;
        [DataMember(Order = 6)]
        public Fixation? Fixation;
        [DataMember(Order = 7)]
        public Health? Health;
        [DataMember(Order = 8)]
        public HexMap? HexMap;
        [DataMember(Order = 9)]
        public ImpactDistance? ImpactDistance;
        [DataMember(Order = 10)]
        public Level? Level;
        [DataMember(Order = 11)]
        public MaxHealth? MaxHealth;
        [DataMember(Order = 12)]
        public MaxSpeed? MaxSpeed;
        [DataMember(Order = 13)]
        public Position? Position;
        [DataMember(Order = 14)]
        public Radius? Radius;
        [DataMember(Order = 15)]
        public RockId? RockId;
        [DataMember(Order = 16)]
        public Rotation? Rotation;
        [DataMember(Order = 17)]
        public Separation? Separation;
        [DataMember(Order = 18)]
        public Team? Team;
        [DataMember(Order = 19)]
        public TreeId? TreeId;
        [DataMember(Order = 20)]
        public UnitId? UnitId;

        public T? Get<T>()
            where T : struct
        {

            if (typeof(T) == typeof(AutoHeal))
                return Unsafe.As<AutoHeal?, T?>(ref AutoHeal);
            if (typeof(T) == typeof(BehaviourConfig))
                return Unsafe.As<BehaviourConfig?, T?>(ref BehaviourConfig);
            if (typeof(T) == typeof(BehaviourState))
                return Unsafe.As<BehaviourState?, T?>(ref BehaviourState);
            if (typeof(T) == typeof(CactusId))
                return Unsafe.As<CactusId?, T?>(ref CactusId);
            if (typeof(T) == typeof(Damage))
                return Unsafe.As<Damage?, T?>(ref Damage);
            if (typeof(T) == typeof(Direction))
                return Unsafe.As<Direction?, T?>(ref Direction);
            if (typeof(T) == typeof(Fixation))
                return Unsafe.As<Fixation?, T?>(ref Fixation);
            if (typeof(T) == typeof(Health))
                return Unsafe.As<Health?, T?>(ref Health);
            if (typeof(T) == typeof(HexMap))
                return Unsafe.As<HexMap?, T?>(ref HexMap);
            if (typeof(T) == typeof(ImpactDistance))
                return Unsafe.As<ImpactDistance?, T?>(ref ImpactDistance);
            if (typeof(T) == typeof(Level))
                return Unsafe.As<Level?, T?>(ref Level);
            if (typeof(T) == typeof(MaxHealth))
                return Unsafe.As<MaxHealth?, T?>(ref MaxHealth);
            if (typeof(T) == typeof(MaxSpeed))
                return Unsafe.As<MaxSpeed?, T?>(ref MaxSpeed);
            if (typeof(T) == typeof(Position))
                return Unsafe.As<Position?, T?>(ref Position);
            if (typeof(T) == typeof(Radius))
                return Unsafe.As<Radius?, T?>(ref Radius);
            if (typeof(T) == typeof(RockId))
                return Unsafe.As<RockId?, T?>(ref RockId);
            if (typeof(T) == typeof(Rotation))
                return Unsafe.As<Rotation?, T?>(ref Rotation);
            if (typeof(T) == typeof(Separation))
                return Unsafe.As<Separation?, T?>(ref Separation);
            if (typeof(T) == typeof(Team))
                return Unsafe.As<Team?, T?>(ref Team);
            if (typeof(T) == typeof(TreeId))
                return Unsafe.As<TreeId?, T?>(ref TreeId);
            if (typeof(T) == typeof(UnitId))
                return Unsafe.As<UnitId?, T?>(ref UnitId);

            throw new NotSupportedException(typeof(T).Name);
        }

        public void Set<T>(T? data)
            where T : struct
        {

            if (typeof(T) == typeof(AutoHeal))
            {
                AutoHeal = Unsafe.As<T?, AutoHeal?>(ref data);
                return;
            }
            if (typeof(T) == typeof(BehaviourConfig))
            {
                BehaviourConfig = Unsafe.As<T?, BehaviourConfig?>(ref data);
                return;
            }
            if (typeof(T) == typeof(BehaviourState))
            {
                BehaviourState = Unsafe.As<T?, BehaviourState?>(ref data);
                return;
            }
            if (typeof(T) == typeof(CactusId))
            {
                CactusId = Unsafe.As<T?, CactusId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Damage))
            {
                Damage = Unsafe.As<T?, Damage?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Direction))
            {
                Direction = Unsafe.As<T?, Direction?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Fixation))
            {
                Fixation = Unsafe.As<T?, Fixation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Health))
            {
                Health = Unsafe.As<T?, Health?>(ref data);
                return;
            }
            if (typeof(T) == typeof(HexMap))
            {
                HexMap = Unsafe.As<T?, HexMap?>(ref data);
                return;
            }
            if (typeof(T) == typeof(ImpactDistance))
            {
                ImpactDistance = Unsafe.As<T?, ImpactDistance?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Level))
            {
                Level = Unsafe.As<T?, Level?>(ref data);
                return;
            }
            if (typeof(T) == typeof(MaxHealth))
            {
                MaxHealth = Unsafe.As<T?, MaxHealth?>(ref data);
                return;
            }
            if (typeof(T) == typeof(MaxSpeed))
            {
                MaxSpeed = Unsafe.As<T?, MaxSpeed?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Position))
            {
                Position = Unsafe.As<T?, Position?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Radius))
            {
                Radius = Unsafe.As<T?, Radius?>(ref data);
                return;
            }
            if (typeof(T) == typeof(RockId))
            {
                RockId = Unsafe.As<T?, RockId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Rotation))
            {
                Rotation = Unsafe.As<T?, Rotation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Separation))
            {
                Separation = Unsafe.As<T?, Separation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Team))
            {
                Team = Unsafe.As<T?, Team?>(ref data);
                return;
            }
            if (typeof(T) == typeof(TreeId))
            {
                TreeId = Unsafe.As<T?, TreeId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(UnitId))
            {
                UnitId = Unsafe.As<T?, UnitId?>(ref data);
                return;
            }

            throw new NotSupportedException(typeof(T).Name);
        }
    }
}
