//------------------------------------------------------------------------------
// <auto-generated>
//
// This code was generated by a tool.
// Path: ..\..\..\Generators\ComponentsDataGenerator.cs
//
// Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated.
// 
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using DVG.Core;

using DVG.SkyPirates.Shared.Components.Runtime;
using DVG.SkyPirates.Shared.Components.Config;
using DVG.SkyPirates.Shared.Components.Framed;
using DVG.SkyPirates.Shared.Ids;
using DVG.SkyPirates.Shared.Components.Special;

namespace DVG.SkyPirates.Shared.Data
{
    [Serializable]
    [DataContract]
    public sealed class ComponentsData: IStructGenericCaller
    {

        [DataMember(Order = 0)]
        public AutoHeal? AutoHeal;
        [DataMember(Order = 1)]
        public BehaviourConfig? BehaviourConfig;
        [DataMember(Order = 2)]
        public BehaviourState? BehaviourState;
        [DataMember(Order = 3)]
        public CachePosition? CachePosition;
        [DataMember(Order = 4)]
        public CactusId? CactusId;
        [DataMember(Order = 5)]
        public Damage? Damage;
        [DataMember(Order = 6)]
        public Destination? Destination;
        [DataMember(Order = 7)]
        public Direction? Direction;
        [DataMember(Order = 8)]
        public Dispose? Dispose;
        [DataMember(Order = 9)]
        public Fixation? Fixation;
        [DataMember(Order = 10)]
        public Health? Health;
        [DataMember(Order = 11)]
        public HexMap? HexMap;
        [DataMember(Order = 12)]
        public ImpactDistance? ImpactDistance;
        [DataMember(Order = 13)]
        public Level? Level;
        [DataMember(Order = 14)]
        public MaxHealth? MaxHealth;
        [DataMember(Order = 15)]
        public MaxSpeed? MaxSpeed;
        [DataMember(Order = 16)]
        public Position? Position;
        [DataMember(Order = 17)]
        public Radius? Radius;
        [DataMember(Order = 18)]
        public RecivedDamage? RecivedDamage;
        [DataMember(Order = 19)]
        public RockId? RockId;
        [DataMember(Order = 20)]
        public Rotation? Rotation;
        [DataMember(Order = 21)]
        public Separation? Separation;
        [DataMember(Order = 22)]
        public SeparationForce? SeparationForce;
        [DataMember(Order = 23)]
        public Squad? Squad;
        [DataMember(Order = 24)]
        public SquadMember? SquadMember;
        [DataMember(Order = 25)]
        public SquadMemberCount? SquadMemberCount;
        [DataMember(Order = 26)]
        public SyncId? SyncId;
        [DataMember(Order = 27)]
        public Target? Target;
        [DataMember(Order = 28)]
        public Targets? Targets;
        [DataMember(Order = 29)]
        public TargetSearchDistance? TargetSearchDistance;
        [DataMember(Order = 30)]
        public TargetSearchPosition? TargetSearchPosition;
        [DataMember(Order = 31)]
        public Team? Team;
        [DataMember(Order = 32)]
        public TreeId? TreeId;
        [DataMember(Order = 33)]
        public UnitId? UnitId;

        public T? Get<T>()
            where T : struct
        {

            if (typeof(T) == typeof(AutoHeal))
                return Unsafe.As<AutoHeal?, T?>(ref AutoHeal);
            if (typeof(T) == typeof(BehaviourConfig))
                return Unsafe.As<BehaviourConfig?, T?>(ref BehaviourConfig);
            if (typeof(T) == typeof(BehaviourState))
                return Unsafe.As<BehaviourState?, T?>(ref BehaviourState);
            if (typeof(T) == typeof(CachePosition))
                return Unsafe.As<CachePosition?, T?>(ref CachePosition);
            if (typeof(T) == typeof(CactusId))
                return Unsafe.As<CactusId?, T?>(ref CactusId);
            if (typeof(T) == typeof(Damage))
                return Unsafe.As<Damage?, T?>(ref Damage);
            if (typeof(T) == typeof(Destination))
                return Unsafe.As<Destination?, T?>(ref Destination);
            if (typeof(T) == typeof(Direction))
                return Unsafe.As<Direction?, T?>(ref Direction);
            if (typeof(T) == typeof(Dispose))
                return Unsafe.As<Dispose?, T?>(ref Dispose);
            if (typeof(T) == typeof(Fixation))
                return Unsafe.As<Fixation?, T?>(ref Fixation);
            if (typeof(T) == typeof(Health))
                return Unsafe.As<Health?, T?>(ref Health);
            if (typeof(T) == typeof(HexMap))
                return Unsafe.As<HexMap?, T?>(ref HexMap);
            if (typeof(T) == typeof(ImpactDistance))
                return Unsafe.As<ImpactDistance?, T?>(ref ImpactDistance);
            if (typeof(T) == typeof(Level))
                return Unsafe.As<Level?, T?>(ref Level);
            if (typeof(T) == typeof(MaxHealth))
                return Unsafe.As<MaxHealth?, T?>(ref MaxHealth);
            if (typeof(T) == typeof(MaxSpeed))
                return Unsafe.As<MaxSpeed?, T?>(ref MaxSpeed);
            if (typeof(T) == typeof(Position))
                return Unsafe.As<Position?, T?>(ref Position);
            if (typeof(T) == typeof(Radius))
                return Unsafe.As<Radius?, T?>(ref Radius);
            if (typeof(T) == typeof(RecivedDamage))
                return Unsafe.As<RecivedDamage?, T?>(ref RecivedDamage);
            if (typeof(T) == typeof(RockId))
                return Unsafe.As<RockId?, T?>(ref RockId);
            if (typeof(T) == typeof(Rotation))
                return Unsafe.As<Rotation?, T?>(ref Rotation);
            if (typeof(T) == typeof(Separation))
                return Unsafe.As<Separation?, T?>(ref Separation);
            if (typeof(T) == typeof(SeparationForce))
                return Unsafe.As<SeparationForce?, T?>(ref SeparationForce);
            if (typeof(T) == typeof(Squad))
                return Unsafe.As<Squad?, T?>(ref Squad);
            if (typeof(T) == typeof(SquadMember))
                return Unsafe.As<SquadMember?, T?>(ref SquadMember);
            if (typeof(T) == typeof(SquadMemberCount))
                return Unsafe.As<SquadMemberCount?, T?>(ref SquadMemberCount);
            if (typeof(T) == typeof(SyncId))
                return Unsafe.As<SyncId?, T?>(ref SyncId);
            if (typeof(T) == typeof(Target))
                return Unsafe.As<Target?, T?>(ref Target);
            if (typeof(T) == typeof(Targets))
                return Unsafe.As<Targets?, T?>(ref Targets);
            if (typeof(T) == typeof(TargetSearchDistance))
                return Unsafe.As<TargetSearchDistance?, T?>(ref TargetSearchDistance);
            if (typeof(T) == typeof(TargetSearchPosition))
                return Unsafe.As<TargetSearchPosition?, T?>(ref TargetSearchPosition);
            if (typeof(T) == typeof(Team))
                return Unsafe.As<Team?, T?>(ref Team);
            if (typeof(T) == typeof(TreeId))
                return Unsafe.As<TreeId?, T?>(ref TreeId);
            if (typeof(T) == typeof(UnitId))
                return Unsafe.As<UnitId?, T?>(ref UnitId);

            throw new NotSupportedException(typeof(T).Name);
        }

        public void Set<T>(T? data)
            where T : struct
        {

            if (typeof(T) == typeof(AutoHeal))
            {
                AutoHeal = Unsafe.As<T?, AutoHeal?>(ref data);
                return;
            }
            if (typeof(T) == typeof(BehaviourConfig))
            {
                BehaviourConfig = Unsafe.As<T?, BehaviourConfig?>(ref data);
                return;
            }
            if (typeof(T) == typeof(BehaviourState))
            {
                BehaviourState = Unsafe.As<T?, BehaviourState?>(ref data);
                return;
            }
            if (typeof(T) == typeof(CachePosition))
            {
                CachePosition = Unsafe.As<T?, CachePosition?>(ref data);
                return;
            }
            if (typeof(T) == typeof(CactusId))
            {
                CactusId = Unsafe.As<T?, CactusId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Damage))
            {
                Damage = Unsafe.As<T?, Damage?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Destination))
            {
                Destination = Unsafe.As<T?, Destination?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Direction))
            {
                Direction = Unsafe.As<T?, Direction?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Dispose))
            {
                Dispose = Unsafe.As<T?, Dispose?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Fixation))
            {
                Fixation = Unsafe.As<T?, Fixation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Health))
            {
                Health = Unsafe.As<T?, Health?>(ref data);
                return;
            }
            if (typeof(T) == typeof(HexMap))
            {
                HexMap = Unsafe.As<T?, HexMap?>(ref data);
                return;
            }
            if (typeof(T) == typeof(ImpactDistance))
            {
                ImpactDistance = Unsafe.As<T?, ImpactDistance?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Level))
            {
                Level = Unsafe.As<T?, Level?>(ref data);
                return;
            }
            if (typeof(T) == typeof(MaxHealth))
            {
                MaxHealth = Unsafe.As<T?, MaxHealth?>(ref data);
                return;
            }
            if (typeof(T) == typeof(MaxSpeed))
            {
                MaxSpeed = Unsafe.As<T?, MaxSpeed?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Position))
            {
                Position = Unsafe.As<T?, Position?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Radius))
            {
                Radius = Unsafe.As<T?, Radius?>(ref data);
                return;
            }
            if (typeof(T) == typeof(RecivedDamage))
            {
                RecivedDamage = Unsafe.As<T?, RecivedDamage?>(ref data);
                return;
            }
            if (typeof(T) == typeof(RockId))
            {
                RockId = Unsafe.As<T?, RockId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Rotation))
            {
                Rotation = Unsafe.As<T?, Rotation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Separation))
            {
                Separation = Unsafe.As<T?, Separation?>(ref data);
                return;
            }
            if (typeof(T) == typeof(SeparationForce))
            {
                SeparationForce = Unsafe.As<T?, SeparationForce?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Squad))
            {
                Squad = Unsafe.As<T?, Squad?>(ref data);
                return;
            }
            if (typeof(T) == typeof(SquadMember))
            {
                SquadMember = Unsafe.As<T?, SquadMember?>(ref data);
                return;
            }
            if (typeof(T) == typeof(SquadMemberCount))
            {
                SquadMemberCount = Unsafe.As<T?, SquadMemberCount?>(ref data);
                return;
            }
            if (typeof(T) == typeof(SyncId))
            {
                SyncId = Unsafe.As<T?, SyncId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Target))
            {
                Target = Unsafe.As<T?, Target?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Targets))
            {
                Targets = Unsafe.As<T?, Targets?>(ref data);
                return;
            }
            if (typeof(T) == typeof(TargetSearchDistance))
            {
                TargetSearchDistance = Unsafe.As<T?, TargetSearchDistance?>(ref data);
                return;
            }
            if (typeof(T) == typeof(TargetSearchPosition))
            {
                TargetSearchPosition = Unsafe.As<T?, TargetSearchPosition?>(ref data);
                return;
            }
            if (typeof(T) == typeof(Team))
            {
                Team = Unsafe.As<T?, Team?>(ref data);
                return;
            }
            if (typeof(T) == typeof(TreeId))
            {
                TreeId = Unsafe.As<T?, TreeId?>(ref data);
                return;
            }
            if (typeof(T) == typeof(UnitId))
            {
                UnitId = Unsafe.As<T?, UnitId?>(ref data);
                return;
            }

            throw new NotSupportedException(typeof(T).Name);
        }

        public Type[] GetTypes()
        {
            int typesCount = 

                (AutoHeal.HasValue? 1 : 0) + 
                (BehaviourConfig.HasValue? 1 : 0) + 
                (BehaviourState.HasValue? 1 : 0) + 
                (CachePosition.HasValue? 1 : 0) + 
                (CactusId.HasValue? 1 : 0) + 
                (Damage.HasValue? 1 : 0) + 
                (Destination.HasValue? 1 : 0) + 
                (Direction.HasValue? 1 : 0) + 
                (Dispose.HasValue? 1 : 0) + 
                (Fixation.HasValue? 1 : 0) + 
                (Health.HasValue? 1 : 0) + 
                (HexMap.HasValue? 1 : 0) + 
                (ImpactDistance.HasValue? 1 : 0) + 
                (Level.HasValue? 1 : 0) + 
                (MaxHealth.HasValue? 1 : 0) + 
                (MaxSpeed.HasValue? 1 : 0) + 
                (Position.HasValue? 1 : 0) + 
                (Radius.HasValue? 1 : 0) + 
                (RecivedDamage.HasValue? 1 : 0) + 
                (RockId.HasValue? 1 : 0) + 
                (Rotation.HasValue? 1 : 0) + 
                (Separation.HasValue? 1 : 0) + 
                (SeparationForce.HasValue? 1 : 0) + 
                (Squad.HasValue? 1 : 0) + 
                (SquadMember.HasValue? 1 : 0) + 
                (SquadMemberCount.HasValue? 1 : 0) + 
                (SyncId.HasValue? 1 : 0) + 
                (Target.HasValue? 1 : 0) + 
                (Targets.HasValue? 1 : 0) + 
                (TargetSearchDistance.HasValue? 1 : 0) + 
                (TargetSearchPosition.HasValue? 1 : 0) + 
                (Team.HasValue? 1 : 0) + 
                (TreeId.HasValue? 1 : 0) + 
                (UnitId.HasValue? 1 : 0);
            
            Type[] types = new Type[typesCount];
            int i = 0;


            if(AutoHeal.HasValue)
                types[i++] = typeof(AutoHeal);
            if(BehaviourConfig.HasValue)
                types[i++] = typeof(BehaviourConfig);
            if(BehaviourState.HasValue)
                types[i++] = typeof(BehaviourState);
            if(CachePosition.HasValue)
                types[i++] = typeof(CachePosition);
            if(CactusId.HasValue)
                types[i++] = typeof(CactusId);
            if(Damage.HasValue)
                types[i++] = typeof(Damage);
            if(Destination.HasValue)
                types[i++] = typeof(Destination);
            if(Direction.HasValue)
                types[i++] = typeof(Direction);
            if(Dispose.HasValue)
                types[i++] = typeof(Dispose);
            if(Fixation.HasValue)
                types[i++] = typeof(Fixation);
            if(Health.HasValue)
                types[i++] = typeof(Health);
            if(HexMap.HasValue)
                types[i++] = typeof(HexMap);
            if(ImpactDistance.HasValue)
                types[i++] = typeof(ImpactDistance);
            if(Level.HasValue)
                types[i++] = typeof(Level);
            if(MaxHealth.HasValue)
                types[i++] = typeof(MaxHealth);
            if(MaxSpeed.HasValue)
                types[i++] = typeof(MaxSpeed);
            if(Position.HasValue)
                types[i++] = typeof(Position);
            if(Radius.HasValue)
                types[i++] = typeof(Radius);
            if(RecivedDamage.HasValue)
                types[i++] = typeof(RecivedDamage);
            if(RockId.HasValue)
                types[i++] = typeof(RockId);
            if(Rotation.HasValue)
                types[i++] = typeof(Rotation);
            if(Separation.HasValue)
                types[i++] = typeof(Separation);
            if(SeparationForce.HasValue)
                types[i++] = typeof(SeparationForce);
            if(Squad.HasValue)
                types[i++] = typeof(Squad);
            if(SquadMember.HasValue)
                types[i++] = typeof(SquadMember);
            if(SquadMemberCount.HasValue)
                types[i++] = typeof(SquadMemberCount);
            if(SyncId.HasValue)
                types[i++] = typeof(SyncId);
            if(Target.HasValue)
                types[i++] = typeof(Target);
            if(Targets.HasValue)
                types[i++] = typeof(Targets);
            if(TargetSearchDistance.HasValue)
                types[i++] = typeof(TargetSearchDistance);
            if(TargetSearchPosition.HasValue)
                types[i++] = typeof(TargetSearchPosition);
            if(Team.HasValue)
                types[i++] = typeof(Team);
            if(TreeId.HasValue)
                types[i++] = typeof(TreeId);
            if(UnitId.HasValue)
                types[i++] = typeof(UnitId);
            
            return types;
        }

        public void ForEach<T>(ref T action)
            where T: IStructGenericAction
        {

            if(AutoHeal.HasValue)
                action.Invoke<AutoHeal>();
            if(BehaviourConfig.HasValue)
                action.Invoke<BehaviourConfig>();
            if(BehaviourState.HasValue)
                action.Invoke<BehaviourState>();
            if(CachePosition.HasValue)
                action.Invoke<CachePosition>();
            if(CactusId.HasValue)
                action.Invoke<CactusId>();
            if(Damage.HasValue)
                action.Invoke<Damage>();
            if(Destination.HasValue)
                action.Invoke<Destination>();
            if(Direction.HasValue)
                action.Invoke<Direction>();
            if(Dispose.HasValue)
                action.Invoke<Dispose>();
            if(Fixation.HasValue)
                action.Invoke<Fixation>();
            if(Health.HasValue)
                action.Invoke<Health>();
            if(HexMap.HasValue)
                action.Invoke<HexMap>();
            if(ImpactDistance.HasValue)
                action.Invoke<ImpactDistance>();
            if(Level.HasValue)
                action.Invoke<Level>();
            if(MaxHealth.HasValue)
                action.Invoke<MaxHealth>();
            if(MaxSpeed.HasValue)
                action.Invoke<MaxSpeed>();
            if(Position.HasValue)
                action.Invoke<Position>();
            if(Radius.HasValue)
                action.Invoke<Radius>();
            if(RecivedDamage.HasValue)
                action.Invoke<RecivedDamage>();
            if(RockId.HasValue)
                action.Invoke<RockId>();
            if(Rotation.HasValue)
                action.Invoke<Rotation>();
            if(Separation.HasValue)
                action.Invoke<Separation>();
            if(SeparationForce.HasValue)
                action.Invoke<SeparationForce>();
            if(Squad.HasValue)
                action.Invoke<Squad>();
            if(SquadMember.HasValue)
                action.Invoke<SquadMember>();
            if(SquadMemberCount.HasValue)
                action.Invoke<SquadMemberCount>();
            if(SyncId.HasValue)
                action.Invoke<SyncId>();
            if(Target.HasValue)
                action.Invoke<Target>();
            if(Targets.HasValue)
                action.Invoke<Targets>();
            if(TargetSearchDistance.HasValue)
                action.Invoke<TargetSearchDistance>();
            if(TargetSearchPosition.HasValue)
                action.Invoke<TargetSearchPosition>();
            if(Team.HasValue)
                action.Invoke<Team>();
            if(TreeId.HasValue)
                action.Invoke<TreeId>();
            if(UnitId.HasValue)
                action.Invoke<UnitId>();
        }
    }
}
